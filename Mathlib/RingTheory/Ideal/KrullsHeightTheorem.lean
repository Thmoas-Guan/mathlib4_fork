/-
Copyright (c) 2025 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Wanyi He, Jiedong Jiang, Christian Merten, Jingting Wang, Andrew Yang, Shouxin Zhang
-/
import Mathlib.RingTheory.HopkinsLevitzki
import Mathlib.RingTheory.Ideal.Height
import Mathlib.RingTheory.Ideal.GoingDown
import Mathlib.RingTheory.Localization.Submodule
import Mathlib.RingTheory.Nakayama
import Mathlib.RingTheory.PrincipalIdealDomain
import Mathlib.Algebra.Polynomial.FieldDivision
import Mathlib.RingTheory.KrullDimension.NonZeroDivisors

/-!
# Krull's Height Theorem

In this file, we prove **Krull's principal ideal theorem** (also known as
**Krullscher Hauptidealsatz**), and **Krull's height theorem** (also known as
**Krullscher Höhensatz**).

## Main Results

* `Ideal.height_le_one_of_isPrincipal_of_mem_minimalPrimes` : This theorem is the
  **Krull's principal ideal theorem** (also known as **Krullscher Hauptidealsatz**), which states
  that: In a commutative Noetherian ring `R`, any prime ideal that is minimal over a principal ideal
  has height at most 1.

* `Ideal.height_le_spanRank_toENat_of_mem_minimal_primes` : This theorem is the
  **Krull's height theorem** (also known as **Krullscher Höhensatz**), which states that:
  In a commutative Noetherian ring `R`, any prime ideal that is minimal over an ideal generated by
  `n` elements has height at most `n`.

* `Ideal.height_le_spanRank_toENat` : This theorem is a corollary of the **Krull's height theorem**
  (also known as **Krullscher Höhensatz**). In a commutative Noetherian ring `R`, the height of
  a (finitely-generated) ideal is smaller than or equal to the minimum number of generators for
  this ideal.

* `Ideal.height_le_iff_exists_minimal_primes` : In a commutative Noetherian ring `R`, a prime ideal
  `p` has height no greater than `n` if and only if it is a minimal ideal over some ideal generated
  by no more than `n` elements.
-/

variable {R : Type*} [CommRing R] [IsNoetherianRing R]

lemma IsLocalRing.quotient_artinian_of_mem_minimalPrimes_of_isLocalRing
    [IsLocalRing R] (I : Ideal R) (hp : IsLocalRing.maximalIdeal R ∈ I.minimalPrimes) :
    IsArtinianRing (R ⧸ I) :=
  have : Ring.KrullDimLE 0 (R ⧸ I) := Ring.krullDimLE_zero_iff.mpr fun J prime ↦
    Ideal.isMaximal_of_isIntegral_of_isMaximal_comap _ <| by
      convert IsLocalRing.maximalIdeal.isMaximal R
      rw [Ideal.minimalPrimes, Set.mem_setOf] at hp
      have := prime.comap (Ideal.Quotient.mk I)
      exact hp.eq_of_le ⟨this, .trans (by simp) (Ideal.ker_le_comap _)⟩ (le_maximalIdeal this.1)
  IsNoetherianRing.isArtinianRing_of_krullDimLE_zero

lemma Ideal.height_le_one_of_isPrincipal_of_mem_minimalPrimes_of_isLocalRing
    [IsLocalRing R] (I : Ideal R) [I.IsPrincipal]
    (hp : (IsLocalRing.maximalIdeal R) ∈ I.minimalPrimes) :
    (IsLocalRing.maximalIdeal R).height ≤ 1 := by
  refine Ideal.height_le_iff.mpr fun q h₁ h₂ ↦ ?_
  suffices q.height = 0 by rw [this]; exact zero_lt_one
  rw [← WithBot.coe_inj,
    ← IsLocalization.AtPrime.ringKrullDim_eq_height q (Localization.AtPrime q),
    WithBot.coe_zero, ← ringKrullDimZero_iff_ringKrullDim_eq_zero,
    ← isArtinianRing_iff_krullDimLE_zero, isArtinianRing_iff_isNilpotent_maximalIdeal,
    ← Localization.AtPrime.map_eq_maximalIdeal]
  have : IsArtinianRing (R ⧸ I) :=
    IsLocalRing.quotient_artinian_of_mem_minimalPrimes_of_isLocalRing I hp
  let f := algebraMap R (Localization.AtPrime q)
  let qs : ℕ →o (Ideal (R ⧸ I))ᵒᵈ :=
    { toFun n := ((q.map f ^ n).comap f).map (Ideal.Quotient.mk I)
      monotone' i j e := Ideal.map_mono (Ideal.comap_mono (Ideal.pow_le_pow_right e)) }
  obtain ⟨n, hn⟩ := IsArtinian.monotone_stabilizes qs
  refine ⟨n, ?_⟩
  apply Submodule.eq_bot_of_le_smul_of_le_jacobson_bot (q.map f) _ (IsNoetherian.noetherian _)
  rotate_left
  · rw [IsLocalRing.jacobson_eq_maximalIdeal, Localization.AtPrime.map_eq_maximalIdeal]
    exact bot_ne_top
  rw [smul_eq_mul, ← pow_succ',
    ← (IsLocalization.orderEmbedding q.primeCompl (Localization.AtPrime q)).map_rel_iff]
  refine Submodule.le_of_le_smul_of_le_jacobson_bot (I := I) (IsNoetherian.noetherian _) ?_ ?_
  · rw [IsLocalRing.jacobson_eq_maximalIdeal]
    exacts [hp.1.2, bot_ne_top]
  · replace hn := congr(Ideal.comap (Ideal.Quotient.mk I) $(hn _ n.le_succ))
    simp only [qs, OrderHom.coe_mk, ← RingHom.ker_eq_comap_bot, Ideal.mk_ker,
      Ideal.comap_map_of_surjective _ Ideal.Quotient.mk_surjective] at hn
    intro x hx
    obtain ⟨y, hy, z, hz, rfl⟩ := Submodule.mem_sup.mp (hn.le (Ideal.mem_sup_left hx))
    refine Submodule.add_mem_sup hy ?_
    obtain ⟨z, rfl⟩ := (Submodule.IsPrincipal.mem_iff_eq_smul_generator I).mp hz
    rw [smul_eq_mul, smul_eq_mul, mul_comm]
    refine Ideal.mul_mem_mul ?_ (Submodule.IsPrincipal.generator_mem _)
    dsimp [IsLocalization.orderEmbedding] at hx
    rwa [Ideal.mem_comap, f.map_add, f.map_mul, Ideal.add_mem_iff_right _
      (Ideal.pow_le_pow_right n.le_succ hy), mul_comm, Ideal.unit_mul_mem_iff_mem] at hx
    refine IsLocalization.map_units (M := q.primeCompl) _ ⟨_, ?_⟩
    change Submodule.IsPrincipal.generator I ∉ (↑q : Set R)
    rw [← Set.singleton_subset_iff, ← Ideal.span_le, Ideal.span_singleton_generator]
    exact fun e ↦ h₂.not_ge (hp.2 ⟨h₁, e⟩ h₂.le)

/-- **Krull's principal ideal theorem** (also known as **Krullscher Hauptidealsatz**) :
  In a commutative Noetherian ring `R`, any prime ideal that is minimal over a principal ideal
  has height at most 1. -/
lemma Ideal.height_le_one_of_isPrincipal_of_mem_minimalPrimes
    (I : Ideal R) [I.IsPrincipal] (p : Ideal R) (hp : p ∈ I.minimalPrimes) : p.height ≤ 1 := by
  have := hp.1.1
  let f := algebraMap R (Localization.AtPrime p)
  have := Ideal.height_le_one_of_isPrincipal_of_mem_minimalPrimes_of_isLocalRing (I.map f) ?_
  · rwa [← IsLocalization.height_comap p.primeCompl,
      Localization.AtPrime.comap_maximalIdeal] at this
  · rwa [IsLocalization.minimalPrimes_map p.primeCompl (Localization.AtPrime p) I,
      Set.mem_preimage, Localization.AtPrime.comap_maximalIdeal]

theorem Ideal.map_height_le_one_of_mem_minimalPrimes {I p : Ideal R} {x : R}
    (hp : p ∈ (I ⊔ span {x}).minimalPrimes) : (p.map (Ideal.Quotient.mk I)).height ≤ 1 :=
  let f := Ideal.Quotient.mk I
  have : p.IsPrime := hp.1.1
  have hfp : RingHom.ker f ≤ p := I.mk_ker.trans_le (le_sup_left.trans hp.1.2)
  height_le_one_of_isPrincipal_of_mem_minimalPrimes ((span {x}).map f) (p.map f)
    ⟨⟨map_isPrime_of_surjective Quotient.mk_surjective hfp, map_mono (le_sup_right.trans hp.1.2)⟩,
      fun _ ⟨hr, hxr⟩ hrp ↦ map_le_iff_le_comap.mpr <| hp.2 ⟨hr.comap f, sup_le_iff.mpr
        ⟨I.mk_ker.symm.trans_le <| ker_le_comap (Ideal.Quotient.mk I), le_comap_of_map_le hxr⟩⟩ <|
          (comap_mono hrp).trans <| Eq.le <|
            (p.comap_map_of_surjective _ Quotient.mk_surjective).trans <| sup_eq_left.mpr hfp⟩

/-- If `q < p` are prime ideals such that `p` is minimal over `span (s ∪ {x})` and
`t` is a set contained in `q` such that `s ⊆ √span (t ∪ {x})`, then `q` is minimal over `span t`.
This is used in the induction step for the proof of Krull's height theorem. -/
theorem Ideal.mem_minimalPrimes_span_of_mem_minimalPrimes_span_insert {q p : Ideal R} [q.IsPrime]
    (hqp : q < p) (x : R) (s : Set R) (hp : p ∈ (span (insert x s)).minimalPrimes)
    (t : Set R) (htq : t ⊆ q) (hsp : s ⊆ (span (insert x t)).radical) :
    q ∈ (span t).minimalPrimes := by
  let f := Quotient.mk (span t)
  have hf : Function.Surjective f := Quotient.mk_surjective
  have hI'q : span t ≤ q := span_le.mpr htq
  have hI'p : span t ≤ p := hI'q.trans hqp.le
  have := minimalPrimes_isPrime hp
  have : (p.map f).IsPrime := map_isPrime_of_surjective hf (by rwa [mk_ker])
  suffices h : (p.map f).height ≤ 1 by
    have h_lt : q.map f < p.map f := (map_mono hqp.le).lt_of_not_ge fun e ↦ hqp.not_ge <| by
      simpa only [comap_map_of_surjective f hf, ← RingHom.ker_eq_comap_bot, f, mk_ker,
        sup_eq_left.mpr hI'q, sup_eq_left.mpr hI'p] using comap_mono (f := f) e
    have : (q.map f).IsPrime := map_isPrime_of_surjective hf (by rwa [mk_ker])
    have : (p.map f).FiniteHeight := ⟨Or.inr (h.trans_lt (WithTop.coe_lt_top 1)).ne⟩
    rw [height_eq_primeHeight] at h
    have := (primeHeight_strict_mono h_lt).trans_le h
    rw [ENat.lt_one_iff_eq_zero, primeHeight_eq_zero_iff] at this
    have := minimal_primes_comap_of_surjective hf this
    rwa [comap_map_of_surjective f hf, ← RingHom.ker_eq_comap_bot,
      mk_ker, sup_eq_left.mpr hI'q] at this
  refine height_le_one_of_isPrincipal_of_mem_minimalPrimes ((span {x}).map f) (p.map f) ⟨⟨this,
    map_mono <| span_le.mpr <| Set.singleton_subset_iff.mpr <| hp.1.2 <| subset_span <| .inl rfl⟩,
    fun r ⟨hr, hxr⟩ hrp ↦ map_le_iff_le_comap.mpr (hp.2 ⟨hr.comap f, ?_⟩ ?_)⟩
  · rw [span_le, Set.insert_subset_iff]
    have := map_le_iff_le_comap.mp hxr (subset_span rfl)
    refine ⟨this, hsp.trans ((hr.comap f).isRadical.radical_le_iff.mpr ?_)⟩
    rw [span_le, Set.insert_subset_iff]
    exact ⟨this, span_le.mp (mk_ker.symm.trans_le (ker_le_comap _))⟩
  · conv_rhs => rw [← sup_eq_left.mpr hI'p, ← (span t).mk_ker, RingHom.ker_eq_comap_bot,
      ← comap_map_of_surjective f hf p]
    exact comap_mono hrp

open IsLocalRing in
/-- **Krull's height theorem** (also known as **Krullscher Höhensatz**) :
  In a commutative Noetherian ring `R`, any prime ideal that is minimal over an ideal generated
  by `n` elements has height at most `n`. -/
nonrec lemma Ideal.height_le_spanRank_toENat_of_mem_minimal_primes
    (I : Ideal R) (p : Ideal R) (hp : p ∈ I.minimalPrimes) :
    p.height ≤ I.spanRank.toENat := by
  classical
  rw [I.spanRank_toENat_eq_iInf_finset_card, le_iInf_iff]
  rintro ⟨s, (rfl : span s = I)⟩
  induction hn : s.card using Nat.strong_induction_on generalizing R with
  | h n H =>
    replace hn : s.card ≤ n := hn.le
    have := hp.1.1
    cases n with
    | zero =>
      rw [ENat.coe_zero, nonpos_iff_eq_zero, height_eq_primeHeight p,
        primeHeight_eq_zero_iff, minimalPrimes]
      simp_all
    | succ n =>
      wlog hR : ∃ (_ : IsLocalRing R), p = maximalIdeal R
      · rw [← Localization.AtPrime.comap_maximalIdeal (I := p)] at hp ⊢
        rw [IsLocalization.height_comap p.primeCompl]
        rw [← Set.mem_preimage, ← IsLocalization.minimalPrimes_map p.primeCompl, map_span] at hp
        exact this _ (s.image (algebraMap R (Localization p.primeCompl))) (by simpa using hp)
          inferInstance _ H (Finset.card_image_le.trans hn) ⟨inferInstance, rfl⟩
      obtain ⟨_, rfl⟩ := hR
      simp_rw [height_le_iff_covBy, ENat.coe_add, ENat.coe_one, ENat.lt_coe_add_one_iff]
      intro q hq hpq hq'
      obtain ⟨x, s', hxs', rfl, hxq⟩ : ∃ x s', x ∉ s' ∧ s = insert x s' ∧ x ∉ q := by
        have : ¬(s : Set R) ⊆ q := by
          rw [← span_le]
          exact fun e ↦ lt_irrefl _ ((hp.2 ⟨hq, e⟩ hpq.le).trans_lt hpq)
        obtain ⟨x, hxt, hxq⟩ := Set.not_subset.mp this
        exact ⟨x, _, fun e ↦ (Finset.mem_erase.mp e).1 rfl, (Finset.insert_erase hxt).symm, hxq⟩
      have : maximalIdeal R ≤ (q ⊔ span {x}).radical := by
        rw [radical_eq_sInf, le_sInf_iff]
        exact fun J ⟨hJ, hJ'⟩ ↦ by_contra fun h ↦ hq' J hJ' ((SetLike.lt_iff_le_and_exists.mpr
          ⟨le_sup_left, x, mem_sup_right (mem_span_singleton_self _), hxq⟩).trans_le hJ)
          ((le_maximalIdeal hJ'.ne_top).lt_of_not_ge h)
      have h : (s' : Set R) ⊆ (q ⊔ span {x}).radical := by
        have := hp.1.2.trans this
        rw [span_le, Finset.coe_insert, Set.insert_subset_iff] at this
        exact this.2
      obtain ⟨t, ht, hspan⟩ := exists_subset_radical_span_sup_of_subset_radical_sup _ _ _ h
      let t := Finset.univ.image t
      suffices hq : q ∈ (span t).minimalPrimes from
        have tcard : t.card ≤ n := Nat.le_of_lt_succ ((Finset.card_image_le.trans_lt <| by
          simpa using Finset.card_lt_card (Finset.ssubset_insert hxs')).trans_le hn)
        (H _ (tcard.trans_lt n.lt_succ_self) q t hq rfl).trans (by norm_cast)
      rw [Finset.coe_insert] at hp
      convert mem_minimalPrimes_span_of_mem_minimalPrimes_span_insert hpq _ _ hp _ ht ?_
      · simp [t]
      refine hspan.trans <| radical_mono ?_
      rw [← Set.union_singleton, span_union]

lemma Ideal.height_le_card_of_mem_minimalPrimes {p : Ideal R} {s : Finset R}
    (hI : p ∈ (Ideal.span s).minimalPrimes) :
    p.height ≤ s.card := by
  trans (Cardinal.toENat (Submodule.spanRank (Ideal.span (s : Set R))))
  · exact Ideal.height_le_spanRank_toENat_of_mem_minimal_primes _ _ hI
  · simpa using Submodule.spanRank_span_le_card (s : Set R)

/-- In a commutative Noetherian ring `R`, the height of a (finitely-generated) ideal is smaller
than or equal to the minimum number of generators for this ideal. -/
lemma Ideal.height_le_spanRank_toENat (I : Ideal R) (hI : I ≠ ⊤) :
    I.height ≤ I.spanRank.toENat := by
  obtain ⟨J, hJ⟩ := nonempty_minimalPrimes hI
  refine (iInf₂_le J hJ).trans ?_
  convert (I.height_le_spanRank_toENat_of_mem_minimal_primes J hJ)
  exact Eq.symm (@height_eq_primeHeight _ _ J hJ.1.1)

lemma Ideal.height_le_spanFinrank (I : Ideal R) (hI : I ≠ ⊤) :
    I.height ≤ I.spanFinrank := by
  have : I.spanFinrank = I.spanRank.toENat := by
    rw [Submodule.fg_iff_spanRank_eq_spanFinrank.mpr (IsNoetherian.noetherian I), map_natCast]
  exact this ▸ height_le_spanRank_toENat I hI

lemma Ideal.height_le_spanRank (I : Ideal R) (hI : I ≠ ⊤) :
    I.height ≤ I.spanRank := by
  trans ↑I.spanRank.toENat
  · exact_mod_cast I.height_le_spanRank_toENat hI
  · exact I.spanRank.ofENat_toENat_le

instance Ideal.finiteHeight_of_isNoetherianRing (I : Ideal R) :
    I.FiniteHeight := finiteHeight_iff_lt.mpr <| Or.elim (em (I = ⊤)) Or.inl
  fun h ↦ Or.inr <| (I.height_le_spanFinrank h).trans_lt (ENat.coe_lt_top _)

instance [IsNoetherianRing R] [IsLocalRing R] : FiniteRingKrullDim R := by
  apply finiteRingKrullDim_iff_ne_bot_and_top.mpr
  rw [← IsLocalRing.maximalIdeal_height_eq_ringKrullDim]
  constructor
  · exact WithBot.coe_ne_bot
  · rw [← WithBot.coe_top, ne_eq, WithBot.coe_inj]
    exact ((IsLocalRing.maximalIdeal R).finiteHeight_iff.mp
      (IsLocalRing.maximalIdeal R).finiteHeight_of_isNoetherianRing).resolve_left
        Ideal.IsPrime.ne_top'

lemma Ideal.exists_spanRank_eq_and_height_eq (I : Ideal R) (hI : I ≠ ⊤) :
    ∃ J ≤ I, J.spanRank = I.height ∧ J.height = I.height := by
  obtain ⟨J, hJ₁, hJ₂, hJ₃⟩ := exists_spanRank_le_and_le_height_of_le_height I _
    (ENat.coe_toNat_le_self I.height)
  rw [ENat.coe_toNat_eq_self.mpr (Ideal.height_ne_top hI)] at hJ₃
  refine ⟨J, hJ₁, le_antisymm ?_ (le_trans ?_ (J.height_le_spanRank ?_)),
    le_antisymm (Ideal.height_mono hJ₁) hJ₃⟩
  · convert hJ₂
    exact Cardinal.ofENat_eq_nat.mpr (ENat.coe_toNat (I.height_ne_top hI)).symm
  · exact Cardinal.ofENat_le_ofENat_of_le hJ₃
  · rintro rfl
    exact hI (top_le_iff.mp hJ₁)

/-- In a commutative Noetherian ring `R`, a prime ideal `p` has height no greater than `n` if and
only if it is a minimal ideal over some ideal generated by no more than `n` elements. -/
lemma Ideal.height_le_iff_exists_minimalPrimes (p : Ideal R) [p.IsPrime]
    (n : ℕ∞) : p.height ≤ n ↔ ∃ I : Ideal R, p ∈ I.minimalPrimes ∧ I.spanRank ≤ n := by
  constructor
  · intro h
    obtain ⟨I, hI, e₁, e₂⟩ := exists_spanRank_eq_and_height_eq p (IsPrime.ne_top ‹_›)
    refine ⟨I, Ideal.mem_minimalPrimes_of_height_eq hI e₂.ge, e₁.symm ▸ ?_⟩
    norm_cast
  · rintro ⟨I, hp, hI⟩
    exact le_trans
      (Ideal.height_le_spanRank_toENat_of_mem_minimal_primes I p hp)
      (by simpa using (Cardinal.toENat.monotone' hI))

/-- If `p` is a prime in a Noetherian ring `R`, there exists a `p`-primary ideal `I`
spanned by `p.height` elements. -/
lemma Ideal.exists_finset_card_eq_height_of_isNoetherianRing (p : Ideal R) [p.IsPrime] :
    ∃ s : Finset R, p ∈ (span s).minimalPrimes ∧ s.card = p.height := by
  obtain ⟨I, hI, hr⟩ := (p.height_le_iff_exists_minimalPrimes <| p.height).mp le_rfl
  have hs : I.generators.Finite := (IsNoetherian.noetherian I).finite_generators
  refine ⟨hs.toFinset, by rwa [hs.coe_toFinset, span, I.span_generators], ?_⟩
  rw [← Set.ncard_eq_toFinset_card (hs := hs), (IsNoetherian.noetherian I).generators_ncard]
  refine le_antisymm ?_ ?_
  · rw [Submodule.fg_iff_spanRank_eq_spanFinrank.mpr (IsNoetherian.noetherian I)] at hr
    exact Cardinal.nat_le_ofENat.mp hr
  · convert_to p.height ≤ I.spanRank.toENat
    · symm
      simpa [Submodule.fg_iff_spanRank_eq_spanFinrank] using (IsNoetherian.noetherian I)
    · exact I.height_le_spanRank_toENat_of_mem_minimal_primes _ hI

section Algebra

variable {S : Type*} [CommRing S] [Algebra R S]

/--
If `P` lies over `p`, the height of `P` is bounded by the height of `p` plus
the height of the image of `P` in `S ⧸ p S`.
Equality holds if `S` satisfies going-down as an `R`-algebra.
-/
lemma Ideal.height_le_height_add_of_liesOver [IsNoetherianRing S] (p : Ideal R) [p.IsPrime]
      (P : Ideal S) [P.IsPrime] [P.LiesOver p] :
    P.height ≤ p.height +
      (P.map (Ideal.Quotient.mk <| p.map (algebraMap R S))).height := by
  classical
  obtain ⟨s, hp, heq⟩ := p.exists_finset_card_eq_height_of_isNoetherianRing
  let P' := P.map (Ideal.Quotient.mk <| p.map (algebraMap R S))
  obtain ⟨s', hP', heq'⟩ := P'.exists_finset_card_eq_height_of_isNoetherianRing
  have hsP'sub : (s' : Set <| S ⧸ (Ideal.map (algebraMap R S) p)) ⊆ (P' : Set <| S ⧸ _) :=
    fun x hx ↦ hP'.1.2 (Ideal.subset_span hx)
  have : Set.SurjOn (Ideal.Quotient.mk (p.map (algebraMap R S))) P s' := by
    refine Set.SurjOn.mono subset_rfl hsP'sub fun x hx ↦ ?_
    obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective x
    rw [SetLike.mem_coe, Ideal.mem_quotient_iff_mem] at hx
    use y, hx
    rw [Ideal.map_le_iff_le_comap, Ideal.LiesOver.over (p := p) (P := P)]
  obtain ⟨o, himgo, hcardo, ho⟩ := s'.exists_image_eq_and_card_le_of_surjOn (P : Set S) this
  let t : Finset S := Finset.image (algebraMap R S) s ∪ o
  suffices h : P.height ≤ t.card by
    rw [← heq, ← heq']
    apply le_trans h
    norm_cast
    exact le_trans (Finset.card_union_le _ _) (add_le_add Finset.card_image_le hcardo)
  refine Ideal.height_le_card_of_mem_minimalPrimes ?_
  have : Ideal.span t = Ideal.map (algebraMap R S) (.span s) ⊔ .span o := by
    simp [t, Ideal.span_union, Ideal.map_span]
  refine this ▸ map_sup_mem_minimalPrimes_of_map_quotientMk_mem_minimalPrimes hp (span_le.mpr ho) ?_
  convert hP'
  simp [Ideal.map_span, ← himgo]

/--
If `S` satisfies going-down as an `R`-algebra and `P` lies over `p`, the height of `P` is equal
to the height of `p` plus the height of the image of `P` in `S ⧸ p S`
(Matsumura 13.B Th. 19 (2)).
-/
lemma Ideal.height_eq_height_add_of_liesOver_of_hasGoingDown [IsNoetherianRing S]
    [Algebra.HasGoingDown R S] (p : Ideal R) [p.IsPrime] (P : Ideal S) [P.IsPrime] [P.LiesOver p] :
    P.height = p.height +
      (P.map (Ideal.Quotient.mk <| p.map (algebraMap R S))).height := by
  refine le_antisymm (height_le_height_add_of_liesOver p P) ?_
  obtain ⟨lp, hlp, hlenp⟩ := p.exists_ltSeries_length_eq_height
  obtain ⟨lq, hlq, hlenq⟩ :=
    (P.map (Quotient.mk (p.map (algebraMap R S)))).exists_ltSeries_length_eq_height
  let l' : LTSeries (PrimeSpectrum S) := lq.map ((Quotient.mk (p.map (algebraMap R S))).specComap)
    (RingHom.strictMono_specComap_of_surjective Quotient.mk_surjective)
  have : l'.head.asIdeal.LiesOver lp.last.asIdeal := by
    simp only [LTSeries.head_map, hlp, l']
    refine ⟨?_⟩
    refine le_antisymm ?_ ?_
    · rw [← map_le_iff_le_comap, ← map_le_iff_le_comap]
      simp
    · conv_rhs => rw [LiesOver.over (p := p) (P := P), under_def]
      refine comap_mono (le_trans (comap_mono (lq.head_le_last)) ?_)
      simp [hlq, map_le_iff_le_comap, LiesOver.over (p := p) (P := P)]
  obtain ⟨lp', hlp'len, hlp', _⟩ := exists_ltSeries_of_hasGoingDown lp l'.head.asIdeal
  have : (lp'.smash l' hlp').length = lp.length + lq.length := by simp [hlp'len, l']
  rw [← hlenp, ← hlenq, ← Nat.cast_add, ← this, height_eq_primeHeight]
  apply Order.length_le_height
  simp [hlq, l', ← PrimeSpectrum.asIdeal_le_asIdeal, map_le_iff_le_comap,
    LiesOver.over (p := p) (P := P)]

open Polynomial

lemma Ideal.map_isMaximal_of_surjective {R S F : Type*} [Ring R] [Ring S] [FunLike F R S]
    [rc : RingHomClass F R S] {f : F}
    (hf : Function.Surjective ⇑f) {I : Ideal R} [H : I.IsMaximal]
    (hk : RingHom.ker f ≤ I) : (Ideal.map f I).IsMaximal := by
  have := Ideal.map_eq_top_or_isMaximal_of_surjective f hf H
  rw [or_iff_not_imp_left] at this
  apply this
  by_contra h
  replace h := congr_arg (comap f) h
  rw [comap_map_of_surjective _ hf, comap_top] at h
  have := eq_top_iff.mpr <| h ▸ sup_le (le_of_eq rfl) hk
  exact H.ne_top this

section
variable {α : Type*} [Preorder α] {x : α}
lemma Order.zero_lt_height [OrderBot α] (h : ⊥ < x) : 0 < Order.height x := by
  rw [← Order.height_bot (α := α)]
  apply Order.height_strictMono
  · exact h
  · rw [Order.height_bot]
    exact ENat.top_pos

lemma Order.one_lt_height_iff : 1 < Order.height x ↔ ∃ y z, z < y ∧ y < x := by
  rw [← not_iff_not, not_lt, Order.height_le_iff']
  constructor
  all_goals intro h
  · by_contra hexist
    rcases hexist with ⟨y,z,hzlty, hyltx⟩
    let p : LTSeries α := RelSeries.fromListChain' [z, y, x] (List.cons_ne_nil z [y, x])
      (List.Chain'.cons hzlty <| List.chain'_pair.mpr hyltx)
    have : RelSeries.last p = x := rfl
    have hle1 : p.length ≤ 1 := ENat.coe_le_coe.mp (h this)
    have hgt1 : p.length > 1 := Nat.one_lt_succ_succ [].length
    linarith
  · intro p hlast
    contrapose! h
    rw [Nat.one_lt_cast] at h
    use p ⟨1, Nat.lt_add_right 1 h⟩, p ⟨0, Nat.zero_lt_succ p.length⟩
    constructor
    · exact LTSeries.strictMono p <| Batteries.compareOfLessAndEq_eq_lt.mp rfl
    · rw [← hlast]
      apply LTSeries.strictMono p
      rw [Fin.mk_lt_mk, Fin.val_last]
      exact h

end

lemma IsMaximal.height_eq_one {R : Type*} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R]
    (m : Ideal R) [hm : m.IsMaximal] (h : ¬ IsField R) :
    m.height = 1 := by
  rw [Ideal.height_eq_primeHeight]
  unfold Ideal.primeHeight
  apply le_antisymm
  · by_contra! hlen
    rw [Order.one_lt_height_iff] at hlen
    rcases hlen with ⟨y, z, hzlty, hyltm⟩
    have hyltm' : y.asIdeal < m := hyltm
    have : y.asIdeal.IsMaximal := IsPrime.to_maximal_ideal <| LT.lt.ne_bot hzlty
    have : y.asIdeal = m := by
      apply Ideal.IsMaximal.eq_of_le this
      exact Ideal.IsPrime.ne_top'
      apply le_of_lt hyltm
    exact (Eq.not_gt this.symm) hyltm
  · have : 0 < Order.height (⟨m, hm.isPrime⟩ : PrimeSpectrum R) ↔
      1 ≤ Order.height (⟨m, hm.isPrime⟩ : PrimeSpectrum R) := by
      exact Iff.symm Order.one_le_iff_pos
    rw [← this]
    apply Order.zero_lt_height
    exact Ideal.bot_lt_of_maximal m h

omit [IsNoetherianRing R] [Algebra R S] in
lemma height_eq_of_ringEquiv (e : R ≃+* S) (p : Ideal R) [hp : p.IsPrime] :
    (p.map e).height = p.height := by
  set g := PrimeSpectrum.comapEquiv e
  have eq : Ideal.map e p = Ideal.comap e.symm p := Ideal.map_comap_of_equiv e
  set f : PrimeSpectrum R ≃o PrimeSpectrum S := { g with
    map_rel_iff' := by
      intro a b
      unfold g PrimeSpectrum.comapEquiv RingHom.specComap
      simp only [RingEquiv.toRingHom_eq_coe, Equiv.coe_fn_mk, ← PrimeSpectrum.asIdeal_le_asIdeal,
        ← Ideal.map_le_iff_le_comap, Ideal.map_comap_of_equiv, RingEquiv.symm_symm]
      apply Iff.of_eq
      congr
      calc
        _ = Ideal.comap e.toRingHom (Ideal.comap (e.symm.toRingHom) a.asIdeal) := by rfl
        _ = _ := by simp }
  rw [Ideal.height_eq_primeHeight, Ideal.height_eq_primeHeight]
  unfold Ideal.primeHeight
  rw [← Order.height_orderIso f ⟨p, hp⟩]
  congr

/-- Let `p` be a prime ideal of `A`. If `P` is a prime ideal of `A[X]` maximal
among the prime ideals lying over `p`, `ht(P) = ht(p) + 1`. -/
lemma Ideal.primeHeight_polynomial_of_isMaximal (p : Ideal R)
    [p.IsMaximal] (P : Ideal R[X]) [P.IsMaximal] [P.LiesOver p] :
    P.height = p.height + 1 := by
  letI : Field (R ⧸ p) := Quotient.field p
  have : (P.map (Ideal.Quotient.mk (Ideal.map (algebraMap R R[X]) p))).height = 1 := by
    let e : (R[X] ⧸ (Ideal.map C p)) ≃+* (R ⧸ p)[X] :=
      (Ideal.polynomialQuotientEquivQuotientPolynomial p).symm
    let P' : Ideal (R ⧸ p)[X] :=
      Ideal.map e <| Ideal.map (Ideal.Quotient.mk <| Ideal.map (algebraMap R R[X]) p) P
    -- use that `P'` is a maximal ideal of `(A ⧸ p)[X]`
    have : (P.map (Ideal.Quotient.mk <| map (algebraMap R R[X]) p)).IsMaximal := by
      apply Ideal.map_isMaximal_of_surjective
      · exact Quotient.mk_surjective
      rw [mk_ker]
      have : Ideal.comap (algebraMap R R[X]) P = p := by
        exact Eq.symm LiesOver.over
      rw [← this]
      exact map_comap_le
    letI : P'.IsMaximal := map_isMaximal_of_equiv e
    have : P'.height = 1 := IsMaximal.height_eq_one P' polynomial_not_isField
    simp only [P'] at this
    rwa [← height_eq_of_ringEquiv e <|
      P.map (Ideal.Quotient.mk <| p.map (algebraMap R R[X]))]
  rw [height_eq_height_add_of_liesOver_of_hasGoingDown p, this]

omit [IsNoetherianRing R] in
@[simp]
lemma Ideal.height_bot [Nontrivial R] : (⊥ : Ideal R).height = 0 := by
  obtain ⟨p, hp⟩ := Ideal.nonempty_minimalPrimes (R := R) (I := ⊥) top_ne_bot.symm
  simp only [Ideal.height, ENat.iInf_eq_zero]
  exact ⟨p, hp, haveI := hp.1.1; primeHeight_eq_zero_iff.mpr hp⟩

instance (p : Ideal R) [p.IsPrime] : (p.map C).IsPrime :=
  Ideal.isPrime_map_C_of_isPrime ‹_›

open Ideal in
lemma Polynomial.height_map_C (p : Ideal R) [p.IsMaximal] : (p.map C).height = p.height := by
  have : (p.map C).LiesOver p := ⟨IsMaximal.eq_of_le inferInstance IsPrime.ne_top' le_comap_map⟩
  simp [height_eq_height_add_of_liesOver_of_hasGoingDown p]

omit [IsNoetherianRing R] in
/-- `dim A ≤ n` if and only if the height of all prime ideals is less than `n`. -/
lemma ringKrullDim_le_of_height_le [Nontrivial R] (n : WithBot ℕ∞) :
    ringKrullDim R ≤ n ↔ ∀ (p : Ideal R), (hp : p.IsPrime) → p.height ≤ n := by
  rw [ringKrullDim, Order.krullDim_eq_iSup_height]
  simp only [iSup_le_iff]
  refine ⟨fun h p hp ↦ ?_, fun h p ↦ ?_⟩
  · rw [Ideal.height_eq_primeHeight]
    exact h ⟨p, hp⟩
  · specialize h p.1 p.2
    rwa [Ideal.height_eq_primeHeight] at h

omit [IsNoetherianRing R] in
/-- `dim A ≤ n` if and only if the height of all maximal ideals is less than `n`. -/
lemma ringKrullDim_le_of_isMaximal_height_le [Nontrivial R] (n : WithBot ℕ∞) :
    ringKrullDim R ≤ n ↔ ∀ (m : Ideal R), (hm : m.IsMaximal) → m.height ≤ n := by
  rw [ringKrullDim_le_of_height_le]
  refine ⟨fun h m hm ↦ h m hm.isPrime, fun h p hp ↦ ?_⟩
  obtain ⟨m, hm, hle⟩ := p.exists_le_maximal hp.ne_top
  refine le_trans ?_ (h m hm)
  norm_cast
  exact Ideal.height_mono hle

@[simp]
lemma LTSeries.height_head_longestOf (α : Type*) [Preorder α] [FiniteDimensionalOrder α] :
    Order.height (LTSeries.longestOf α).last = Order.krullDim α := by
  refine le_antisymm (Order.height_le_krullDim _) ?_
  rw [Order.krullDim_eq_length_of_finiteDimensionalOrder, Order.height]
  norm_cast
  exact le_iSup_iff.mpr <| fun _ h ↦ iSup_le_iff.mp (h _) le_rfl

lemma Ideal.exists_isMaximal_height_eq_of_nontrivial {R : Type*} [CommRing R]
    [Nontrivial R] [FiniteRingKrullDim R] :
    ∃ (p : Ideal R) (_ : p.IsMaximal), p.height = ringKrullDim R := by
  let l := (LTSeries.longestOf (PrimeSpectrum R))
  obtain ⟨m, hm, hle⟩ := l.last.asIdeal.exists_le_maximal IsPrime.ne_top'
  use m, hm
  refine le_antisymm (height_le_ringKrullDim_of_ne_top IsPrime.ne_top') ?_
  trans (l.last.asIdeal.height : WithBot ℕ∞)
  · rw [Ideal.height_eq_primeHeight]
    exact ((LTSeries.height_head_longestOf _).symm).le
  · norm_cast
    exact height_mono hle

omit [IsNoetherianRing R] [Algebra R S] in
lemma IsLocalization.height_eq_of_disjoint [Algebra R S] (M : Submonoid R)
    [IsLocalization M S] (p : Ideal R) [p.IsPrime] (h : Disjoint (M : Set R) (p : Set R)) :
    (p.map <| algebraMap R S).height = p.height := by
  set P := p.map (algebraMap R S)
  have : P.IsPrime := IsLocalization.isPrime_of_isPrime_disjoint M S p ‹_› h
  have := isLocalization_isLocalization_atPrime_isLocalization (M := M) (Localization.AtPrime P) P
  simp_rw [P, comap_map_of_isPrime_disjoint M S p _ h] at this
  have := ringKrullDim_eq_of_ringEquiv (IsLocalization.algEquiv p.primeCompl
    (Localization.AtPrime P) (Localization.AtPrime p)).toRingEquiv
  rw [AtPrime.ringKrullDim_eq_height P, AtPrime.ringKrullDim_eq_height p] at this
  exact WithBot.coe_eq_coe.mp this

lemma IsLocalization.IsMaximal_of_IsMaximal_disjoint {R : Type*} [CommSemiring R] (M : Submonoid R)
    (S : Type*) [CommSemiring S] [Algebra R S] [IsLocalization M S] (J : Ideal S)
    (h : (Ideal.comap (algebraMap R S) J).IsMaximal)
    (disj : Disjoint (M : Set R) (Ideal.comap (algebraMap R S) J)) :
    J.IsMaximal := by
  obtain ⟨m, maxm, hm⟩ := Ideal.exists_le_maximal J <| Ideal.IsPrime.ne_top <|
    (IsLocalization.isPrime_iff_isPrime_disjoint M S J).mpr ⟨h.isPrime, disj⟩
  have : (Ideal.comap (algebraMap R S) J) ≤ (Ideal.comap (algebraMap R S) m) := fun x h ↦ by
    rw [Ideal.mem_comap] at h ⊢
    exact (hm h)
  have := Ideal.IsMaximal.eq_of_le h (Ideal.IsPrime.ne_top <| Ideal.IsPrime.under R m) this
  have : J = m := by rw [← IsLocalization.map_comap M S J, ← IsLocalization.map_comap M S m, this]
  exact this ▸ maxm

section

variable (S : Submonoid R) (Rₚ : Type*) [CommRing Rₚ] [Algebra R Rₚ] [IsLocalization S Rₚ]

noncomputable instance : Algebra R[X] Rₚ[X] :=
  RingHom.toAlgebra (Polynomial.mapRingHom (algebraMap R Rₚ))

noncomputable instance : IsScalarTower R R[X] Rₚ[X] := IsScalarTower.of_algebraMap_eq <| by
  have : algebraMap R[X] Rₚ[X] = Polynomial.mapRingHom (algebraMap R Rₚ) := by rfl
  rw [this]
  intro a
  simp only [Polynomial.algebraMap_apply, algebraMap_eq, coe_mapRingHom, map_C]

end

attribute [local instance] Polynomial.isLocalization

/-- Let `p` be a prime ideal of `A`. If `P` is a prime ideal of `A[X]` maximal
among the prime ideals lying over `p`, `ht(P) = ht(p) + 1`. -/
lemma Ideal.primeHeight_polynomial (p : Ideal R)
    [hp : p.IsPrime] (P : Ideal R[X]) [hP : P.IsMaximal] [plo : P.LiesOver p] :
    P.height = p.height + 1 := by
  let Rₚ := Localization.AtPrime p
  have disj : Disjoint (Submonoid.map C p.primeCompl : Set R[X]) P := by
    apply Set.disjoint_left.mpr
    intro a ha1 ha2
    simp only [Submonoid.coe_map, Set.mem_image, SetLike.mem_coe] at ha1
    obtain ⟨b, hb⟩ := ha1
    have : b ∈ p := by
      rw [plo.over, mem_comap, algebraMap_eq]
      exact hb.2 ▸ ha2
    exact hb.1 this
  have eq : (comap (algebraMap R[X] Rₚ[X]) (map (algebraMap R[X] Rₚ[X]) P)) = P :=
      IsLocalization.comap_map_of_isPrime_disjoint _ _ P hP.isPrime disj
  set p' := p.map (algebraMap R Rₚ)
  letI : p'.IsMaximal := by
    have : p' = IsLocalRing.maximalIdeal Rₚ := Localization.AtPrime.map_eq_maximalIdeal
    exact this ▸ IsLocalRing.maximalIdeal.isMaximal Rₚ
  have eq1 : p.height = p'.height := by
    rw [IsLocalization.height_eq_of_disjoint p.primeCompl]
    exact Disjoint.symm <| Set.disjoint_left.mpr fun _ a b ↦ b a
  set P' : Ideal Rₚ[X] := P.map (algebraMap R[X] Rₚ[X])
  have mp : P'.IsMaximal :=
    IsLocalization.IsMaximal_of_IsMaximal_disjoint _ _ _ (eq.symm ▸ hP) (eq.symm ▸ disj)
  have lo : P'.LiesOver p' := by
    constructor
    have h1 : p'.under R = p := IsLocalization.comap_map_of_isPrime_disjoint p.primeCompl
        _ p hp <| Disjoint.symm <| Set.disjoint_left.mpr fun _ a b ↦ b a
    have h2 : P'.under R[X] = P := IsLocalization.comap_map_of_isPrime_disjoint
      (Submonoid.map C <| p.primeCompl) Rₚ[X] P hP.isPrime disj
    have := plo.over
    rw [← h2, Ideal.under_under, ← Ideal.under_under P' (B := Rₚ)] at this
    simp only [p', this]
    nth_rw 1 [Ideal.under_def]
    exact IsLocalization.map_comap p.primeCompl Rₚ (P'.under Rₚ)
  have eq2 : P.height = P'.height := by
    rw [IsLocalization.height_eq_of_disjoint
      (Submonoid.map C <| p.primeCompl) _ disj]
  rw [eq1, eq2]
  apply Ideal.primeHeight_polynomial_of_isMaximal p' P'

lemma ringKrullDim_polynomial : ringKrullDim R[X] = ringKrullDim R + 1 := by
  refine le_antisymm ?_ ?_
  · nontriviality R[X]
    apply (ringKrullDim_le_of_isMaximal_height_le (ringKrullDim R + 1)).mpr
    intro P hP
    let p : Ideal R := P.comap (algebraMap R R[X])
    rw [Ideal.primeHeight_polynomial p P, WithBot.coe_add, WithBot.coe_one]
    gcongr
    exact Ideal.height_le_ringKrullDim_of_ne_top Ideal.IsPrime.ne_top'
  · exact ringKrullDim_succ_le_ringKrullDim_polynomial

open Ideal

/-- If `I ≤ m` and `m` is maximal, the height of `m` is bounded by the height of `m ⧸ I R` plus
the span rank of `I`. -/
lemma Ideal.height_le_height_add_spanFinrank_of_le {I m : Ideal R} [m.IsMaximal] (hrm : I ≤ m) :
    m.height ≤ (m.map (algebraMap R (R ⧸ I))).height + I.spanFinrank := by
  classical
  let R' := R ⧸ I
  let m' := m.map (algebraMap R R')
  have : m'.IsMaximal := Ideal.map_isMaximal_of_surjective Ideal.Quotient.mk_surjective <| by
    simpa [span_le]
  have : m'.LiesOver m := by
    constructor
    simp [m', under]
    apply IsMaximal.eq_of_le
    infer_instance
    exact IsPrime.ne_top'
    exact le_comap_map
  change m.height ≤ m'.height + I.spanFinrank
  obtain ⟨s, hms, hs⟩ := Ideal.exists_finset_card_eq_height_of_isNoetherianRing m'
  rw [← hs]
  have hsm' : (s : Set R') ⊆ (m' : Set R') := fun x hx ↦ hms.1.2 (subset_span hx)
  have : Set.SurjOn (Ideal.Quotient.mk I) m s := by
    refine Set.SurjOn.mono subset_rfl hsm' fun x hx ↦ ?_
    obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x
    simp only [Quotient.algebraMap_eq, SetLike.mem_coe, mem_quotient_iff_mem_sup, hrm,
      sup_of_le_left, R', m'] at hx
    use x, hx
  obtain ⟨o, himgo, hcardo, ho⟩ := s.exists_image_eq_and_card_le_of_surjOn (m : Set R) this
  have hI : I.FG := IsNoetherian.noetherian I
  let u : Finset R := (Submodule.FG.finite_generators hI).toFinset
  let t : Finset R := o ∪ u
  suffices h : m.height ≤ t.card by
    apply le_trans h
    simp [t]
    norm_cast
    have : u.card = I.spanFinrank := by
      rw [← Set.ncard_eq_toFinset_card (hs := Submodule.FG.finite_generators hI)]
      exact Submodule.FG.generators_ncard hI
    trans o.card + u.card
    · exact Finset.card_union_le o u
    · simp [hcardo, this]
  refine Ideal.height_le_card_of_mem_minimalPrimes ?_
  refine ⟨⟨inferInstance, ?_⟩, ?_⟩
  · simp [t]
    rw [span_le]
    simp
    refine ⟨?_, ?_⟩
    · exact ho
    · trans (I : Set R)
      · rw [← Submodule.span_generators I]
        simp [u, subset_span]
      · exact hrm
  · intro q ⟨_, hleq⟩ hqle
    have : I ≤ q := by
      apply le_trans _ hleq
      simp only [Finset.coe_union, t]
      rw [span_union]
      simp only [Set.Finite.coe_toFinset, u]
      conv_lhs => rw [← Submodule.span_generators I]
      simp
    have h2 : m' ≤ Ideal.map (Ideal.Quotient.mk I) q := by
      apply hms.2
      refine ⟨?_, ?_⟩
      · exact map_quotientMk_isPrime_of_isPrime this
      · rw [← himgo]
        simp only [Finset.coe_image, R']
        rw [← map_span]
        exact map_mono (le_trans (span_mono <| by simp [t]) hleq)
      · exact Ideal.map_mono hqle
    apply Ideal.comap_mono (f := Ideal.Quotient.mk I) at h2
    simp only [comap_map_quotientMk, this, sup_of_le_right, m'] at h2
    exact le_trans le_comap_map h2

@[simp]
lemma Submodule.spanFinrank_bot {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] :
    (⊥ : Submodule R M).spanFinrank = 0 := by
   simp [spanFinrank]

lemma Submodule.spanFinrank_eq_zero_iff_eq_bot {R M : Type*} [Semiring R] [AddCommMonoid M]
    [Module R M] {p : Submodule R M} (h : p.FG) :
    p.spanFinrank = 0 ↔ p = ⊥ := by
  refine ⟨fun heq ↦ ?_, fun h ↦ h ▸ by simp⟩
  rw [← Submodule.FG.generators_ncard h, Set.ncard_eq_zero h.finite_generators] at heq
  rw [← p.span_generators, heq, span_empty]

lemma Submodule.spanFinrank_singleton {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]
    {m : M} (hm : m ≠ 0) : (span R {m}).spanFinrank = 1 := by
  apply le_antisymm ?_ ?_
  · exact le_trans (Submodule.spanFinrank_span_le_ncard_of_finite (by simp)) (by simp)
  · by_contra!
    simp [Submodule.spanFinrank_eq_zero_iff_eq_bot (fg_span_singleton m), hm] at this

lemma Submodule.spanFinrank_span_le_encard {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]
    (s : Set M) : (span R s).spanFinrank ≤ s.encard := by
  obtain h | h := s.finite_or_infinite
  · refine le_trans ?_ s.ncard_le_encard
    norm_cast
    exact spanFinrank_span_le_ncard_of_finite h
  · simp [h]

lemma Ideal.height_le_height_add_encard_of_subset (s : Set R) {m : Ideal R} [m.IsMaximal]
    (hrm : s ⊆ m) : m.height ≤ (m.map (algebraMap R (R ⧸ span s))).height + s.encard := by
  apply le_trans (Ideal.height_le_height_add_spanFinrank_of_le (I := span s) (m := m) ?_) ?_
  · rwa [span_le]
  · gcongr
    exact Submodule.spanFinrank_span_le_encard _

lemma Ideal.height_le_height_succ_of_mem {r : R} {m : Ideal R} [m.IsMaximal] (hrm : r ∈ m) :
    m.height ≤ (m.map (Ideal.Quotient.mk (span {r}))).height + 1 := by
  convert Ideal.height_le_height_add_encard_of_subset {r} (m := m) ?_
  · simp
  · simpa

lemma ringKrullDim_quotient_succ_of_mem_nonZeroDivisors {r : R}
    (hr : r ∈ nonZeroDivisors R) {m : Ideal R} [m.IsMaximal]
    (h : m.height = ringKrullDim R) (hm : r ∈ m) :
    ringKrullDim (R ⧸ span {r}) + 1 = ringKrullDim R := by
  refine le_antisymm (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hr) ?_
  rw [← h]
  trans (m.map (algebraMap R (R ⧸ span {r}))).height + 1
  · norm_cast
    exact Ideal.height_le_height_succ_of_mem hm
  · gcongr
    apply Ideal.height_le_ringKrullDim_of_ne_top
    have : (Ideal.map (algebraMap R (R ⧸ span {r})) m).IsMaximal := by
      apply Ideal.map_isMaximal_of_surjective
      apply Ideal.Quotient.mk_surjective
      simp [span_le, hm]
    exact IsPrime.ne_top'

lemma ringKrullDim_ne_bot {R : Type*} [CommSemiring R] [FiniteRingKrullDim R] :
    ringKrullDim R ≠ ⊥ :=
  (finiteRingKrullDim_iff_ne_bot_and_top.mp ‹_›).1

lemma Nontrivial.of_finiteRingKrullDim (R : Type*) [CommSemiring R] [FiniteRingKrullDim R] :
    Nontrivial R := by
  by_contra!
  rw [not_nontrivial_iff_subsingleton] at this
  exact ringKrullDim_ne_bot (R := R) ringKrullDim_eq_bot_of_subsingleton

lemma ringKrullDim_quotient_succ_of_mem_nonZeroDivisors_of_mem_jacobson
    {r : R} (hr₁ : r ∈ nonZeroDivisors R) (hr₂ : r ∈ Ring.jacobson R) :
    ringKrullDim (R ⧸ span {r}) + 1 = ringKrullDim R := by
  refine le_antisymm (ringKrullDim_quotient_succ_le_of_nonZeroDivisor hr₁) ?_
  nontriviality R
  rw [ringKrullDim_le_of_isMaximal_height_le]
  intro m hm
  have hrm : r ∈ m := by
    simp only [Ring.jacobson_eq_sInf_isMaximal, Submodule.mem_sInf, Set.mem_setOf_eq] at hr₂
    exact hr₂ _ hm
  trans (m.map (algebraMap R (R ⧸ span {r}))).height + 1
  · norm_cast
    exact Ideal.height_le_height_succ_of_mem hrm
  · gcongr
    apply Ideal.height_le_ringKrullDim_of_ne_top
    have : (Ideal.map (algebraMap R (R ⧸ span {r})) m).IsMaximal := by
      apply Ideal.map_isMaximal_of_surjective
      apply Ideal.Quotient.mk_surjective
      simp [span_le, hrm]
    exact IsPrime.ne_top'

omit [Algebra R S] in
lemma ringKrullDim_eq_succ_of_surjective_of_mem_jacobson
    {f : R →+* S} (hf : Function.Surjective f) {r : R} (hr₁ : r ∈ nonZeroDivisors R)
    (hr₂ : r ∈ Ring.jacobson R) (hr₃ : RingHom.ker f = span {r}) :
    ringKrullDim R = ringKrullDim S + 1 := by
  refine (ringKrullDim_quotient_succ_of_mem_nonZeroDivisors_of_mem_jacobson hr₁ hr₂).symm.trans ?_
  congr
  rw [← hr₃]
  exact ringKrullDim_eq_of_ringEquiv (RingHom.quotientKerEquivOfSurjective hf)

lemma Polynomial.constantCoeff_surjective (R : Type*) [Semiring R] :
    Function.Surjective (constantCoeff (R := R)) :=
  fun x ↦ ⟨C x, by simp⟩

@[simp]
lemma Polynomial.ker_constantCoeff (R : Type*) [CommSemiring R] :
    RingHom.ker constantCoeff = span {(X : R[X])} := by
  refine le_antisymm (fun p hp ↦ ?_) (by simp [span_le])
  simp only [RingHom.mem_ker, constantCoeff_apply, ← Polynomial.X_dvd_iff] at hp
  rwa [Ideal.mem_span_singleton]

end Algebra
