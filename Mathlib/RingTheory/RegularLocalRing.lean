/-
Copyright (c) 2025 Nailin Guan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nailin Guan
-/
import Mathlib.Algebra.Polynomial.FieldDivision
import Mathlib.RingTheory.Ideal.Cotangent
import Mathlib.RingTheory.Ideal.KrullsHeightTheorem
import Mathlib.RingTheory.KrullDimension.Field
import Mathlib.RingTheory.Regular.RegularSequence
/-!
# Define Regular Local Ring

For a noetherian local ring `R`, we define `IsRegularLocalRing` as
`(maximalIdeal R).spanFinrank = ringKrullDim R`

# Main Definition and Results

* `IsRegularLocalRing` : A noetherian local ring of dimesnion `d` `IsRegularLocalRing` if
  `(maximalIdeal R).spanFinrank = ringKrullDim R`,
  i.e. its maximal ideal can be generated by `d` elements.

* `isRegularLocalRing_iff` : the equivalence of `IsRegularLocalRing` and
  `Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R`

-/

open IsLocalRing

variable (R : Type*) [CommRing R]

/-- A noetherian local ring of dimesnion `d` is said to be regular if its maximal ideal
can be generated by `d` elements. -/
class IsRegularLocalRing : Prop extends IsLocalRing R, IsNoetherianRing R where
  reg : (maximalIdeal R).spanFinrank = ringKrullDim R

lemma isRegularLocalRing_def [IsLocalRing R] [IsNoetherianRing R] :
    IsRegularLocalRing R ↔ (maximalIdeal R).spanFinrank = ringKrullDim R :=
  ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩

lemma ringKrullDim_le_spanFinrank_maximalIdeal [IsLocalRing R] [IsNoetherianRing R] :
    ringKrullDim R ≤ (maximalIdeal R).spanFinrank :=
  le_of_eq_of_le IsLocalRing.maximalIdeal_height_eq_ringKrullDim.symm
    (WithBot.coe_le_coe.mpr (Ideal.height_le_spanFinrank (maximalIdeal R) Ideal.IsPrime.ne_top'))

namespace IsRegularLocalRing

lemma of_span_eq [IsLocalRing R] [IsNoetherianRing R] (S : Set R) (fin : S.Finite)
    (span : Ideal.span S = maximalIdeal R) (card : S.ncard ≤ ringKrullDim R) :
    IsRegularLocalRing R := by
  apply (isRegularLocalRing_def _).mpr (le_antisymm _ (ringKrullDim_le_spanFinrank_maximalIdeal R))
  apply le_trans _ card
  rw [← span, ← Ideal.submodule_span_eq]
  simpa using Submodule.spanFinrank_span_le_ncard_of_finite fin

variable {R} in
lemma of_ringEquiv [IsRegularLocalRing R] {R' : Type*} [CommRing R']
    (e : R ≃+* R') : IsRegularLocalRing R' := by
  let _ := e.isLocalRing
  let _ := isNoetherianRing_of_ringEquiv R e
  have fg : (maximalIdeal R).FG := (isNoetherianRing_iff_ideal_fg R).mp inferInstance _
  apply of_span_eq R' (e '' (maximalIdeal R).generators)
    ((Submodule.FG.finite_generators fg).image _)
  · simp only [← Ideal.map_span]
    rw [← Ideal.submodule_span_eq, Submodule.span_generators (maximalIdeal R), ← Ideal.comap_symm]
    exact ((local_hom_TFAE e.symm.toRingHom).out 0 4).mp (e.symm.surjective.isLocalHom _)
  · simpa [← ringKrullDim_eq_of_ringEquiv e, ← IsRegularLocalRing.reg,
      ← Submodule.FG.generators_ncard fg] using
      Set.ncard_image_le (Submodule.FG.finite_generators fg)

end IsRegularLocalRing

lemma span_eq_top_iff [IsLocalRing R] (S : Set (maximalIdeal R)) :
    Submodule.span R S = ⊤ ↔ Submodule.span R ((Submodule.subtype (maximalIdeal R)) '' S) =
    maximalIdeal R := by
  rw [← Submodule.map_span]
  refine ⟨fun h ↦ by simp [h], fun h ↦ ?_⟩
  rw [← Submodule.comap_map_eq_of_injective (maximalIdeal R).injective_subtype
    (Submodule.span R S), h, Submodule.comap_subtype_self]

open Set in
lemma spanFinrank_maximalIdeal [IsLocalRing R] [IsNoetherianRing R] :
    (maximalIdeal R).spanFinrank = Module.finrank (ResidueField R) (CotangentSpace R) := by
  let fg : Module.Finite (ResidueField R) (CotangentSpace R) := inferInstance
  let fg' : (maximalIdeal R).FG := (isNoetherianRing_iff_ideal_fg R).mp inferInstance _
  have : Submodule.spanFinrank (⊤ : Submodule (ResidueField R) (CotangentSpace R)) =
    Module.rank (ResidueField R) (CotangentSpace R) := by
    rw [← Submodule.fg_iff_spanRank_eq_spanFinrank.mpr fg.1, Submodule.rank_eq_spanRank_of_free]
  simp only [← Module.finrank_eq_rank, Nat.cast_inj] at this
  rw [← this]
  apply le_antisymm
  · have span : Submodule.span R
      ((⊤ : Submodule (ResidueField R) (CotangentSpace R)).generators.image Quotient.out) = ⊤ := by
      apply IsLocalRing.CotangentSpace.span_image_eq_top_iff.mp
      convert Submodule.span_generators (⊤ : Submodule (ResidueField R) (CotangentSpace R))
      have : ⇑(maximalIdeal R).toCotangent ∘ Quotient.out = id := by
        ext
        exact Submodule.Quotient.mk_out _
      rw [← Set.image_comp, this, image_id]
    rw [span_eq_top_iff, ← Set.image_comp] at span
    rw [← Submodule.FG.generators_ncard fg.1, ← congrArg Submodule.spanFinrank span]
    apply le_trans (Submodule.spanFinrank_span_le_ncard_of_finite
      (Finite.image _ fg.1.finite_generators)) (Set.ncard_image_le fg.1.finite_generators)
  · let G := ({x | ↑x ∈ (maximalIdeal R).generators} : Set (maximalIdeal R))
    have : Submodule.span R G = ⊤ := by
      simp only [span_eq_top_iff, Submodule.subtype_apply, Ideal.submodule_span_eq, G]
      convert (maximalIdeal R).span_generators
      ext
      simpa using fun a ↦ Submodule.FG.generators_mem (maximalIdeal R) a
    have fin : G.Finite := Set.Finite.of_injOn (by simp [MapsTo, G]) injOn_subtype_val
        (Submodule.FG.finite_generators fg')
    rw [← IsLocalRing.CotangentSpace.span_image_eq_top_iff.mpr this,
      ← Submodule.FG.generators_ncard fg']
    apply le_trans (Submodule.spanFinrank_span_le_ncard_of_finite (Finite.image _ fin))
    exact le_trans (Set.ncard_image_le fin) (Set.ncard_le_ncard_of_injOn Subtype.val (by simp [G])
      injOn_subtype_val (Submodule.FG.finite_generators fg'))

lemma isRegularLocalRing_iff [IsLocalRing R] [IsNoetherianRing R] :
    IsRegularLocalRing R ↔ Module.finrank (ResidueField R) (CotangentSpace R) = ringKrullDim R := by
  rw [isRegularLocalRing_def, spanFinrank_maximalIdeal]

variable {R} in
lemma IsLocalRing.ResidueField.map_injective [IsLocalRing R] {S : Type*} [CommRing S]
    [IsLocalRing S] (f : R →+* S) [IsLocalHom f] :
    Function.Injective (ResidueField.map f) := by
  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]
  intro x hx
  simpa only [map_eq_zero] using hx

variable {R} in
lemma IsLocalRing.ResidueField.map_bijective_of_surjective [IsLocalRing R] {S : Type*} [CommRing S]
    [IsLocalRing S] (f : R →+* S) (surj : Function.Surjective f) [IsLocalHom f] :
    Function.Bijective (ResidueField.map f) := by
  refine ⟨ResidueField.map_injective f, ?_⟩
  apply Ideal.Quotient.lift_surjective_of_surjective
  convert Function.Surjective.comp (Ideal.Quotient.mk_surjective (I := (maximalIdeal S))) surj

variable {R} in
lemma _root_.ringKrullDim_le_ringKrullDim_add_card [IsLocalRing R] [IsNoetherianRing R]
    {S : Finset R} (hS : (S : Set R) ⊆ maximalIdeal R) :
    ringKrullDim R ≤ ringKrullDim (R ⧸ Ideal.span S.toSet) + S.card := by
  sorry

lemma quotient_isRegularLocalRing_tfae [IsRegularLocalRing R] (S : Finset R)
    (sub : (S : Set R) ⊆ maximalIdeal R) :
    [∃ (T : Finset R), S ⊆ T ∧ T.card = ringKrullDim R ∧ Ideal.span T = maximalIdeal R,
     LinearIndependent (ResidueField R) ((⇑(maximalIdeal R).toCotangent).comp (Set.inclusion sub)),
     IsRegularLocalRing (R ⧸ Ideal.span (S : Set R)) ∧
     (ringKrullDim (R ⧸ Ideal.span (S : Set R)) + S.card = ringKrullDim R)].TFAE := by
  have : Nontrivial (R ⧸ Ideal.span S.toSet) :=
    Ideal.Quotient.nontrivial (ne_top_of_le_ne_top Ideal.IsPrime.ne_top' (Ideal.span_le.mpr sub))
  have lochom : IsLocalHom (Ideal.Quotient.mk (Ideal.span S.toSet)) :=
    IsLocalHom.of_surjective _ (Ideal.Quotient.mk_surjective)
  tfae_have 1 → 2 := by
    rintro ⟨T, h, card, span⟩
    have Tsub : (T : Set R) ⊆ maximalIdeal R := by simpa [← span] using Ideal.subset_span
    have : LinearIndependent (ResidueField R)
      ((⇑(maximalIdeal R).toCotangent).comp (Set.inclusion Tsub)) := by
      apply linearIndependent_of_top_le_span_of_card_eq_finrank
      · simp only [Finset.coe_sort_coe, Set.range_comp, Set.range_inclusion Tsub,
          SetLike.coe_sort_coe, Finset.mem_coe, top_le_iff,
          IsLocalRing.CotangentSpace.span_image_eq_top_iff]
        simp only [span_eq_top_iff, Submodule.subtype_apply, Ideal.submodule_span_eq]
        convert span
        ext
        simpa using fun a ↦ Tsub a
      · rw [← Nat.cast_inj (R := WithBot ℕ∞), (isRegularLocalRing_iff R).mp ‹_›, ← card]
        simp
    have li := LinearIndependent.comp this (Set.inclusion h) (Set.inclusion_injective h)
    have inc : Set.inclusion Tsub ∘ Set.inclusion h = Set.inclusion sub := rfl
    simpa [← Function.comp_assoc, ← inc] using li
  tfae_have 2 → 3 := by
    intro li
    let _ : IsLocalRing (R ⧸ Ideal.span S.toSet) :=
      IsLocalRing.of_surjective _ Ideal.Quotient.mk_surjective
    rw [isRegularLocalRing_def]
    have le := ringKrullDim_le_ringKrullDim_add_card sub
    have ge : (Submodule.spanFinrank (maximalIdeal (R ⧸ Ideal.span S.toSet))) + S.card ≤
      ringKrullDim R := by
      simp only [← Nat.cast_add, ← (isRegularLocalRing_iff R).mp ‹_›, Nat.cast_le,
        spanFinrank_maximalIdeal]
      let f := Ideal.mapCotangent (maximalIdeal R) (maximalIdeal (R ⧸ Ideal.span S.toSet))
        (Ideal.Quotient.mkₐ R (Ideal.span S.toSet)) (fun x hx ↦ by simpa)
      have ker : (LinearMap.ker f : Set (maximalIdeal R).Cotangent) = (Submodule.span
        (ResidueField R) (Set.range (⇑(maximalIdeal R).toCotangent ∘ Set.inclusion sub))) := by
        simp only [ Submodule.coe_span_eq_span_of_surjective R (ResidueField R)
          IsLocalRing.residue_surjective, Finset.coe_sort_coe, SetLike.coe_set_eq]
        ext x
        induction' x using Submodule.Quotient.induction_on with x
        simp only [Ideal.mapCotangent, LinearMap.mem_ker, f]
        change (maximalIdeal (R ⧸ Ideal.span S.toSet)).toCotangent ⟨(Ideal.Quotient.mkₐ R
          (Ideal.span S.toSet)) x, _⟩ = 0 ↔ (maximalIdeal R).toCotangent x ∈ _
        simp only [Ideal.Quotient.mkₐ_eq_mk, Set.range_comp,
          Submodule.span_image', Ideal.toCotangent_eq_zero]
        have : maximalIdeal (R ⧸ Ideal.span S.toSet) =
          (maximalIdeal R).map (Ideal.Quotient.mk _) := by
          simp only [← ((local_hom_TFAE _).out 0 4).mp lochom,
            Ideal.map_comap_of_surjective _ Ideal.Quotient.mk_surjective]
        rw [this, ← Ideal.map_pow, ← Ideal.mem_comap, ← Submodule.mem_comap, Submodule.comap_map_eq,
          Ideal.comap_map_of_surjective' _ Ideal.Quotient.mk_surjective, Ideal.mk_ker, sup_comm,
          ← Submodule.comap_map_eq_of_injective (maximalIdeal R).subtype_injective (Submodule.span
          R (Set.range (Set.inclusion sub)) ⊔ LinearMap.ker (maximalIdeal R).toCotangent)]
        simp only [Finset.coe_sort_coe, Submodule.map_sup, Submodule.mem_comap,
          Submodule.subtype_apply]
        congr!
        · simp only [Submodule.map_span, Submodule.subtype_apply, Ideal.submodule_span_eq]
          congr
          ext
          simpa using fun a ↦ sub a
        · exact (Ideal.map_toCotangent_ker (maximalIdeal R)).symm
      let Q := (CotangentSpace R) ⧸ (Submodule.span (ResidueField R)
        (Set.range (⇑(maximalIdeal R).toCotangent ∘ Set.inclusion sub)))
      let f' : Q →+ (CotangentSpace (R ⧸ Ideal.span S.toSet)) :=
        QuotientAddGroup.lift _ f
        (le_of_eq (AddSubgroup.ext (fun x ↦ (congrFun ker.symm x).to_iff)))
      have bij : Function.Bijective f' := by
        constructor
        · rw [← AddMonoidHom.ker_eq_bot_iff, eq_bot_iff]
          intro x hx
          induction' x using QuotientAddGroup.induction_on with x
          have : x ∈ (LinearMap.ker f : Set (maximalIdeal R).Cotangent) := LinearMap.mem_ker.mpr hx
          rw [ker] at this
          exact AddSubgroup.mem_bot.mpr ((QuotientAddGroup.eq_zero_iff _).mpr this)
        · apply QuotientAddGroup.lift_surjective_of_surjective
          intro x
          rcases Ideal.toCotangent_surjective _ x with ⟨y, hy⟩
          rcases Ideal.Quotient.mk_surjective y.1 with ⟨z, hz⟩
          have : z ∈ maximalIdeal R := by simp [← ((local_hom_TFAE _).out 0 4).mp lochom, hz]
          use (maximalIdeal R).toCotangent ⟨z, this⟩
          simp [f, ← hy, hz]
      let e : Q ≃+ (CotangentSpace (R ⧸ Ideal.span S.toSet)) :=
        AddEquiv.ofBijective f' bij
      have rk := rank_eq_of_equiv_equiv (ResidueField.map (Ideal.Quotient.mk (Ideal.span S.toSet)))
        e (ResidueField.map_bijective_of_surjective _ Ideal.Quotient.mk_surjective) (fun r m ↦ by
          induction' m using Submodule.Quotient.induction_on with m
          rw [← Submodule.Quotient.mk_smul]
          simp only [Finset.coe_sort_coe, AddEquiv.ofBijective_apply, e, f']
          induction' r using Submodule.Quotient.induction_on with r
          change f (r • m) = (ResidueField.map (Ideal.Quotient.mk (Ideal.span S.toSet)))
            (IsLocalRing.residue R r) • (f m)
          simp only [map_smul]
          rfl)
      have frk : Module.finrank (ResidueField R) Q = Module.finrank
        (ResidueField (R ⧸ Ideal.span S.toSet)) (CotangentSpace (R ⧸ Ideal.span S.toSet)) := by
        simp [Module.finrank, rk]
      have : Fintype.card S.toSet = S.card := Fintype.card_ofFinset S (fun x ↦ Finset.mem_coe)
      rw [← frk, ← this, ← finrank_span_eq_card li]
      apply Module.finrank_quotient_add_finrank_le
    have : ringKrullDim (R ⧸ Ideal.span S.toSet) + S.card ≤
      (Submodule.spanFinrank (maximalIdeal (R ⧸ Ideal.span S.toSet))) + S.card :=
      add_le_add_right (ringKrullDim_le_spanFinrank_maximalIdeal _) _
    exact ⟨(withBotENat_add_coe_cancel _ _ S.card).mp
      (le_antisymm (ge.trans le) this), le_antisymm (this.trans ge) le⟩
  tfae_have 3 → 1 := by
    classical
    rintro ⟨reg, dim⟩
    simp only [← (isRegularLocalRing_def _).mp reg, ← Nat.cast_add, ←
      (isRegularLocalRing_def R).mp ‹_›, Nat.cast_inj] at dim
    let fg : (maximalIdeal (R ⧸ Ideal.span S.toSet)).FG :=
      (isNoetherianRing_iff_ideal_fg _).mp inferInstance _
    have fin : (maximalIdeal (R ⧸ Ideal.span S.toSet)).generators.Finite :=
      Submodule.FG.finite_generators fg
    let U := Quotient.out '' (maximalIdeal (R ⧸ Ideal.span S.toSet)).generators
    let _ : Fintype U := (Set.Finite.image _ fin).fintype
    use S ∪ U.toFinset
    have span : Ideal.span (S ∪ U) = maximalIdeal R := by
      rw [Ideal.span_union, ← Ideal.mk_ker (I := Ideal.span S.toSet), sup_comm,
        ← Ideal.comap_map_of_surjective' _ Ideal.Quotient.mk_surjective, Ideal.map_span]
      have : Ideal.span (⇑(Ideal.Quotient.mk (Ideal.span ↑S)) '' U) =
        Submodule.span _ (maximalIdeal (R ⧸ Ideal.span S.toSet)).generators := by
        simp [U, ← Set.image_comp]
      rw [this, Submodule.span_generators]
      exact ((local_hom_TFAE _).out 0 4).mp lochom
    simp only [Finset.subset_union_left, true_and, ← (isRegularLocalRing_def R).mp ‹_›,
      Finset.coe_union, Set.coe_toFinset]
    refine ⟨le_antisymm ?_ ?_, span⟩
    · apply Nat.cast_le.mpr (le_trans (Finset.card_union_le _ _) _)
      simp only [Set.toFinset_card, ← dim, add_comm, add_le_add_iff_left]
      rw [Fintype.card_eq_nat_card, Nat.card_coe_set_eq]
      apply le_trans (Set.ncard_image_le fin) (le_of_eq (Submodule.FG.generators_ncard fg))
    · simp only [← span, ← Set.ncard_coe_finset, Finset.coe_union, Set.coe_toFinset, Nat.cast_le]
      exact Submodule.spanFinrank_span_le_ncard_of_finite (Set.toFinite (S ∪ U))
  tfae_finish

lemma quotient_span_singleton [IsRegularLocalRing R] {x : R} (mem : x ∈ maximalIdeal R)
    (nmem : x ∉ (maximalIdeal R) ^ 2) : IsRegularLocalRing (R ⧸ Ideal.span {x}) ∧
    (ringKrullDim (R ⧸ Ideal.span {x}) + 1 = ringKrullDim R) := by
  have : ({x} : Finset R).toSet = {x} := by exact Finset.coe_singleton x
  rw [← Nat.cast_one, ← Finset.card_singleton x, ← Finset.coe_singleton x]
  apply ((quotient_isRegularLocalRing_tfae R {x} (by simpa)).out 1 2).mp
  simpa [← LinearMap.mem_ker, Ideal.mem_toCotangent_ker] using nmem

lemma exist_nat_eq [FiniteRingKrullDim R] : ∃ n : ℕ, ringKrullDim R = n := by
  have : (ringKrullDim R).unbot ringKrullDim_ne_bot ≠ ⊤ := by
    by_contra eq
    rw [← WithBot.coe_inj, WithBot.coe_unbot, WithBot.coe_top] at eq
    exact ringKrullDim_ne_top eq
  use ((ringKrullDim R).unbot ringKrullDim_ne_bot).toNat
  exact (WithBot.coe_unbot (ringKrullDim R) ringKrullDim_ne_bot).symm.trans
    (WithBot.coe_inj.mpr (ENat.coe_toNat this).symm)

open Pointwise in
theorem isDomain_of_isRegularLocalRing [IsRegularLocalRing R] : IsDomain R := by
  obtain ⟨n, hn⟩ := exist_nat_eq R
  induction' n with n ih generalizing R
  · simp only [← (isRegularLocalRing_def R).mp ‹_›, CharP.cast_eq_zero, Nat.cast_eq_zero] at hn
    have : maximalIdeal R = ⊥ := by
      rw [← Submodule.spanRank_eq_zero_iff_eq_bot, Submodule.fg_iff_spanRank_eq_spanFinrank.mpr
        ((isNoetherianRing_iff_ideal_fg R).mp inferInstance _), hn, Nat.cast_zero]
    exact (isField_iff_maximalIdeal_eq.mpr this).isDomain
  · obtain ⟨x, xmem, xnmem⟩ : ∃ x ∈ maximalIdeal R,
      x ∉ ⋃ I ∈ {(maximalIdeal R) ^ 2} ∪ minimalPrimes R, I := by
      by_contra! h
      have fin : ({(maximalIdeal R) ^ 2} ∪ minimalPrimes R).Finite :=
        Set.Finite.union (Set.finite_singleton _) (minimalPrimes.finite_of_isNoetherianRing R)
      rcases (Ideal.subset_union_prime_finite fin ((maximalIdeal R) ^ 2) ((maximalIdeal R) ^ 2)
        (fun I hI ne _ ↦ Ideal.minimalPrimes_isPrime (by simpa [ne] using hI))).mp h with
        ⟨I, hI, sub⟩
      simp only [Set.singleton_union, Set.mem_insert_iff] at hI
      rcases hI with eq|min
      · have : IsField R := by
          simp only [← subsingleton_cotangentSpace_iff, Ideal.cotangent_subsingleton_iff,
            IsIdempotentElem]
          exact le_antisymm Ideal.mul_le_right (le_of_le_of_eq sub (eq.trans (pow_two _)))
        rw [ringKrullDim_eq_zero_of_isField this, ← Nat.cast_zero, Nat.cast_inj] at hn
        exact Nat.zero_ne_add_one n hn
      · let _ : I.IsPrime := Ideal.minimalPrimes_isPrime min
        rw [← Ideal.primeHeight_eq_ringKrullDim_iff.mpr (le_antisymm (le_maximalIdeal_of_isPrime I)
          sub), Ideal.primeHeight_eq_zero_iff.mpr min, ← Nat.cast_zero] at hn
        exact Nat.zero_ne_add_one n (Nat.cast_inj.mp hn)
    simp only [Set.singleton_union, Set.mem_insert_iff, Set.iUnion_iUnion_eq_or_left, Set.mem_union,
      SetLike.mem_coe, Set.mem_iUnion, exists_prop, not_or, not_exists, not_and] at xnmem
    obtain ⟨reg, dim⟩ := quotient_span_singleton R xmem xnmem.1
    simp only [hn, Nat.cast_add, Nat.cast_one] at dim
    have ih' := ih (R ⧸ Ideal.span {x}) ((withBotENat_add_coe_cancel _ _ 1).mp dim)
    have : (Ideal.span {x}).IsPrime := (Ideal.Quotient.isDomain_iff_prime _).mp ih'
    obtain ⟨p, min, hp⟩ := Ideal.exists_minimalPrimes_le (bot_le (a := Ideal.span {x}))
    let _ : p.IsPrime := Ideal.minimalPrimes_isPrime min
    have eq_smul : p = Ideal.span {x} • p := by
      ext y
      simp only [smul_eq_mul, Ideal.mem_span_singleton_mul]
      refine ⟨fun h ↦ ?_, fun ⟨z, hz, eq⟩ ↦ by simpa [← eq] using Ideal.mul_mem_left p x hz⟩
      rcases Ideal.mem_span_singleton'.mp (hp h) with ⟨z, hz⟩
      use z
      simp only [← hz, mul_comm, and_true]
      have : z ∈ p ∨ x ∈ p := (Ideal.IsPrime.mem_or_mem ‹_›  (by simpa [hz]))
      simpa [xnmem.2 p min] using this
    have pfg : p.FG := (isNoetherianRing_iff_ideal_fg R).mp inferInstance _
    have := Submodule.eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator pfg eq_smul
        (le_trans ((Ideal.span_singleton_le_iff_mem _).mpr xmem) (maximalIdeal_le_jacobson _))
    have : (⊥ : Ideal R).IsPrime := by simpa [← this]
    exact IsDomain.of_bot_isPrime R

open RingTheory.Sequence in
theorem isRegular_of_span_eq_maximalIdeal [IsRegularLocalRing R] (rs : List R)
    (span : Ideal.ofList rs = maximalIdeal R) (len : rs.length = ringKrullDim R) :
    IsRegular R rs := by
  refine ⟨⟨fun i hi ↦ ?_⟩, by simpa [span] using Ideal.IsPrime.ne_top'.symm⟩
  rw [smul_eq_mul, Ideal.mul_top]
  classical
  have mem : (rs.toFinset : Set R) ⊆ maximalIdeal R := by
    intro x hx
    simp only [List.coe_toFinset, Set.mem_setOf_eq] at hx
    exact Ideal.span_le.mp (le_of_eq span) hx
  have sub : (List.take i rs).toFinset ⊆ rs.toFinset :=
    fun x ↦ by simpa using fun a ↦ List.mem_of_mem_take a
  have card : rs.toFinset.card = ringKrullDim R := by
    apply le_antisymm (le_of_le_of_eq (Nat.cast_le.mpr rs.toFinset_card_le) len)
    simp only [← (isRegularLocalRing_def R).mp ‹_›, Nat.cast_le, ← span, Ideal.ofList,
      ← List.coe_toFinset rs]
    exact le_of_le_of_eq (Submodule.spanFinrank_span_le_ncard_of_finite rs.toFinset.finite_toSet)
      (Set.ncard_coe_finset rs.toFinset)
  have reg := ((quotient_isRegularLocalRing_tfae R (List.take i rs).toFinset
    ((Finset.coe_subset.mpr sub).trans mem)).out 0 2).mp (by
      use rs.toFinset
      simpa [sub, card] using span)
  have : IsDomain (R ⧸ Ideal.ofList (List.take i rs)) := by
    refine @isDomain_of_isRegularLocalRing _ _ ?_
    simp only [Ideal.ofList]
    rw [← List.coe_toFinset (List.take i rs)]
    exact reg.1
  apply IsSMulRegular.of_right_eq_zero_of_smul (fun x hx ↦ ?_)
  have : (Ideal.Quotient.mk (Ideal.ofList (List.take i rs))) rs[i] ≠ 0 := by
    simp only [ne_eq, Ideal.Quotient.eq_zero_iff_mem]
    by_contra mem
    simp only [← (isRegularLocalRing_def R).mp ‹_›, Nat.cast_inj] at len
    let rs' := (List.take i rs) ++ (List.drop (i + 1) rs)
    have span' : Ideal.ofList rs' = maximalIdeal R := by
      simp only [← span, rs']
      apply le_antisymm
      · apply Ideal.span_mono (fun x ↦ ?_)
        simpa [or_imp] using ⟨fun a ↦ List.mem_of_mem_take a, fun a ↦ List.mem_of_mem_drop a⟩
      · apply Ideal.span_le.mpr
        intro x hx
        have : rs = List.take i rs ++ (rs[i] :: List.drop (i + 1) rs) := by
          rw [List.cons_getElem_drop_succ, List.take_append_drop]
        rw [this] at hx
        simp only [List.mem_append, List.mem_cons] at hx
        simp only [Ideal.ofList_append, SetLike.mem_coe]
        rcases hx with l|eq|r
        · apply Ideal.mem_sup_left
          apply Ideal.subset_span
          exact l
        · apply Ideal.mem_sup_left
          simpa [eq] using mem
        · apply Ideal.mem_sup_right
          apply Ideal.subset_span
          exact r
    have : Submodule.spanFinrank (maximalIdeal R) ≤ rs'.length := by
      rw [← span']
      apply le_trans (Submodule.spanFinrank_span_le_ncard_of_finite rs'.finite_toSet)
      apply le_of_eq_of_le _ (List.toFinset_card_le rs')
      simp [← (Set.ncard_coe_finset rs'.toFinset)]
    simp only [← len, List.length_append, List.length_take, List.length_drop, rs'] at this
    absurd this
    omega
  exact (mul_eq_zero_iff_left this).mp hx

class IsRegularRing : Prop where
  localization_isRegular : ∀ p : Ideal R, ∀ (_ : p.IsPrime),
    IsRegularLocalRing (Localization.AtPrime p)

lemma isRegularRing_iff : IsRegularRing R ↔ ∀ p : Ideal R, ∀ (_ : p.IsPrime),
    IsRegularLocalRing (Localization.AtPrime p) :=
  ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩

lemma isRegularRing_of_ringEquiv {R R' : Type*} [CommRing R] [CommRing R']
    (e : R ≃+* R') [reg : IsRegularRing R] : IsRegularRing R' := by
  apply (isRegularRing_iff R').mpr (fun p' hp' ↦ ?_)
  let p := p'.comap e
  have : Submonoid.map e.toMonoidHom p.primeCompl = p'.primeCompl := by
    ext x
    have : (∃ y, e y ∉ p' ∧ e y = x) ↔ x ∉ p' := ⟨fun ⟨y, hy, eq⟩ ↦ by simpa [← eq],
      fun h ↦ ⟨e.symm x, by simpa, RingEquiv.apply_symm_apply e x⟩⟩
    simpa only [Ideal.primeCompl, p]
  let _ := (isRegularRing_iff R).mp ‹_› p (Ideal.comap_isPrime e p')
  exact IsRegularLocalRing.of_ringEquiv
    (IsLocalization.ringEquivOfRingEquiv (Localization.AtPrime p) (Localization.AtPrime p') e this)

open Polynomial Ideal

open Set in
lemma Polynomial.localization_at_comap_maximal_isRegularRing_isRegularRing
    [IsRegularLocalRing R] (p : Ideal R[X]) [p.IsPrime] (max : p.comap C = maximalIdeal R) :
    IsRegularLocalRing (Localization.AtPrime p) := by
  apply (isRegularLocalRing_def _).mpr
  apply le_antisymm _ (ringKrullDim_le_spanFinrank_maximalIdeal _)
  let q := (maximalIdeal R).map C
  have qle : q ≤ p := by simpa [q, ← max] using map_comap_le
  have Ker : RingHom.ker (Polynomial.mapRingHom (IsLocalRing.residue R)) = q := by
    simpa only [residue, ker_mapRingHom, q] using congrArg (Ideal.map C) (Quotient.mkₐ_ker R _)
  have reg := (isRegularLocalRing_def R).mp ‹_›
  have fg : (maximalIdeal R).FG := (isNoetherianRing_iff_ideal_fg R).mp inferInstance _
  have fg' := (Submodule.FG.finite_generators fg)
  have ht : (maximalIdeal R).height ≤ q.height := by
    --exact le_of_eq (Polynomial.height_map_C (maximalIdeal R)).symm
    sorry
  by_cases eq0 : p.map (Polynomial.mapRingHom (IsLocalRing.residue R)) = ⊥
  · have eq : p = (maximalIdeal R).map C := le_antisymm
      (by simpa [← Ker, ← Ideal.map_eq_bot_iff_le_ker, q]) qle
    have ht1 : (maximalIdeal R).height ≤ p.height := by simpa [eq]
    have : Ideal.span ((algebraMap R (Localization.AtPrime p)) '' (maximalIdeal R).generators) =
      maximalIdeal (Localization.AtPrime p) := by
      rw [IsScalarTower.algebraMap_eq R R[X] (Localization.AtPrime p), RingHom.coe_comp,
        Set.image_comp, ← Ideal.map_span, ← Ideal.map_span]
      simp only [Ideal.span, (maximalIdeal R).span_generators, algebraMap_eq, ← eq,
        Localization.AtPrime.map_eq_maximalIdeal]
    simp only [← maximalIdeal_height_eq_ringKrullDim, ← IsLocalization.height_comap p.primeCompl,
      IsLocalization.AtPrime.comap_maximalIdeal _ p, ge_iff_le]
    apply le_trans _ (WithBot.coe_le_coe.mpr ht1)
    simp only [maximalIdeal_height_eq_ringKrullDim, ← reg, Nat.cast_le, ← this,
      ← Submodule.FG.generators_ncard fg]
    exact le_trans (Submodule.spanFinrank_span_le_ncard_of_finite (Set.Finite.image _ fg'))
      (Set.ncard_image_le fg')
  · let _ : q.IsPrime := Ideal.isPrime_map_C_of_isPrime (IsMaximal.isPrime' (maximalIdeal R))
    have lt : q < p := by
      apply lt_of_le_of_ne qle
      by_contra eq
      exact eq0 ((map_eq_bot_iff_le_ker _).mpr (le_of_eq (Ker.trans eq).symm))
    let _ : IsPrincipalIdealRing (IsLocalRing.ResidueField R)[X] := inferInstance
    rcases IsPrincipalIdealRing.principal (Ideal.map (mapRingHom (residue R)) p) with ⟨x, hx⟩
    rcases map_surjective (residue R) residue_surjective x with ⟨y, hy⟩
    have peq : p = Ideal.span (((algebraMap R R[X]) '' (maximalIdeal R).generators) ∪ {y}) := by
      calc
      p = p ⊔ RingHom.ker (mapRingHom (residue R)) := by simpa [Ker] using qle
      _ = comap (mapRingHom (residue R)) ((Ideal.span {y}).map (mapRingHom (residue R))) := by
        simp [← Ideal.comap_map_of_surjective' (mapRingHom (residue R))
          (map_surjective (residue R) residue_surjective), hx, Ideal.map_span, hy]
      _ = _ := by
        simp only [Ideal.comap_map_of_surjective' (mapRingHom (residue R))
          (map_surjective (residue R) residue_surjective), Set.union_comm, Ideal.span_union,
          ← Ideal.map_span, Ker, algebraMap_eq, q]
        congr
        exact (maximalIdeal R).span_generators.symm
    simp only [← Localization.AtPrime.map_eq_maximalIdeal, peq, Ideal.map_span]
    rw [← maximalIdeal_height_eq_ringKrullDim, ← IsLocalization.height_comap p.primeCompl,
      IsLocalization.AtPrime.comap_maximalIdeal _ p, Ideal.height_eq_primeHeight]
    apply le_trans _ (WithBot.coe_le_coe.mpr (Ideal.primeHeight_add_one_le_of_lt lt))
    rw [← Ideal.height_eq_primeHeight]
    apply le_trans _ (WithBot.coe_le_coe.mpr (add_le_add_right ht 1))
    rw [WithBot.coe_add, maximalIdeal_height_eq_ringKrullDim, WithBot.coe_one, ← reg,
      ← Nat.cast_one, ← Nat.cast_add, Nat.cast_le]
    have fin : (((algebraMap R R[X]) '' (maximalIdeal R).generators) ∪ {y}).Finite :=
      Finite.union (Finite.image _ fg') (finite_singleton y)
    apply le_trans (Submodule.spanFinrank_span_le_ncard_of_finite (Finite.image _ fin))
    apply le_trans (Set.ncard_image_le fin) (le_trans (Set.ncard_union_le _ _) _)
    rw [ncard_singleton, add_le_add_iff_right]
    exact le_of_le_of_eq (Set.ncard_image_le fg') (Submodule.FG.generators_ncard fg)

theorem Polynomial.isRegularRing_of_isRegularRing [IsRegularRing R] :
    IsRegularRing R[X] := by
  apply (isRegularRing_iff _).mpr (fun p hp ↦ ?_)
  let q := p.comap C
  let S := (Localization.AtPrime q)[X]
  let pc := Submonoid.map Polynomial.C.toMonoidHom q.primeCompl
  let _ : Algebra R[X] S := algebra R (Localization.AtPrime q)
  have _ : IsLocalization pc S := {
    map_units' x := by
      rcases x.2 with ⟨y, mem, eq⟩
      apply isUnit_of_mul_eq_one _ (C (Localization.mk 1 ⟨y, mem⟩))
      simp [← eq, S, ← map_mul, ← Localization.mk_one_eq_algebraMap, Localization.mk_mul]
    surj' z := by
      induction' z using Polynomial.induction_on' with f g hf hg n a
      · rcases hf with ⟨⟨x1, y1⟩, h1⟩
        rcases hg with ⟨⟨x2, y2⟩, h2⟩
        use (x2 * y1.1 + x1 * y2.1, y1 * y2)
        simp only [Submonoid.coe_mul, map_mul, add_mul, map_add]
        nth_rw 4 [mul_comm]
        simp [← mul_assoc, h1, h2, add_comm]
      · rcases Localization.mkHom_surjective a with ⟨⟨x, y⟩, h⟩
        use ((monomial n) x, ⟨C y.1, by simp [pc]⟩)
        simp only [← h, Localization.mkHom_apply, algebraMap_def, coe_mapRingHom, map_C, ←
          Localization.mk_one_eq_algebraMap, monomial_mul_C, map_monomial, S, Localization.mk_mul]
        congr 1
        apply Localization.mk_eq_mk_iff.mpr (Localization.r_of_eq ?_)
        simp [mul_comm]
    exists_of_eq {x y} eq := by
      have eq' (n : ℕ) : (algebraMap R (Localization.AtPrime q)) (Polynomial.coeff x n) =
        (algebraMap R (Localization.AtPrime q)) (Polynomial.coeff y n) := by
        simp only [algebraMap_def, coe_mapRingHom, S] at eq
        have : coeff (map (algebraMap R (Localization.AtPrime q)) x) n =
          coeff (map (algebraMap R (Localization.AtPrime q)) y) n := by rw [eq]
        simpa
      let g : ℕ → q.primeCompl := fun n ↦ Classical.choose (IsLocalization.exists_of_eq (eq' n))
      have g_spec (n : ℕ) := Classical.choose_spec
        (IsLocalization.exists_of_eq (M := q.primeCompl) (eq' n))
      let s := ∏ n ∈ x.1.1 ∪ y.1.1, g n
      use ⟨C s.1, by simp [pc]⟩
      ext n
      simp only [coeff_C_mul, s]
      by_cases mem : n ∈ x.1.1 ∪ y.1.1
      · rcases Finset.dvd_prod_of_mem g mem with ⟨t, ht⟩
        simp only [ht, Submonoid.coe_mul, mul_comm _ t.1, mul_assoc]
        rw [g_spec n]
      · simp only [Finset.mem_union, Finsupp.mem_support_iff, ne_eq, not_or, not_not] at mem
        simp [← Polynomial.toFinsupp_apply, mem] }
  let pS := p.map (algebraMap R[X] S)
  have disj : Disjoint (pc : Set R[X]) (p : Set R[X]) := by
    simpa [pc, q] using Set.disjoint_image_left.mpr
      (Set.disjoint_compl_left_iff_subset.mpr (fun _ a ↦ a))
  have : pS.IsPrime :=  IsLocalization.isPrime_of_isPrime_disjoint pc _ _ ‹_› disj
  have : IsLocalization.AtPrime (Localization.AtPrime pS) p := by
    convert IsLocalization.isLocalization_isLocalization_atPrime_isLocalization pc
      (Localization.AtPrime pS) pS
    exact (IsLocalization.comap_map_of_isPrime_disjoint pc _ _ ‹_› disj).symm
  let _ := (isRegularRing_iff R).mp ‹_› q (comap_isPrime C p)
  have eq : comap C pS = maximalIdeal (Localization.AtPrime q) := by
    rw [← IsLocalization.map_comap q.primeCompl _ (comap C pS),
      ← IsLocalization.map_comap q.primeCompl _ (maximalIdeal (Localization.AtPrime q))]
    simp only [comap_comap, S, pS]
    rw [← Polynomial.algebraMap_eq (R := Localization.AtPrime q),
      ← IsScalarTower.algebraMap_eq R (Localization.AtPrime q) (Localization.AtPrime q)[X],
      IsScalarTower.algebraMap_eq R R[X] (Localization.AtPrime q)[X], ← comap_comap,
      IsLocalization.comap_map_of_isPrime_disjoint pc _ _ ‹_› disj,
      IsLocalization.AtPrime.comap_maximalIdeal (Localization.AtPrime q) q]
    rfl
  let _ := localization_at_comap_maximal_isRegularRing_isRegularRing (Localization.AtPrime q) pS eq
  exact IsRegularLocalRing.of_ringEquiv (IsLocalization.algEquiv p.primeCompl
    (Localization.AtPrime pS) (Localization.AtPrime p)).toRingEquiv

lemma MvPolynomial.isRegularRing_of_isRegularRing [IsRegularRing R] (n : ℕ) :
    IsRegularRing (MvPolynomial (Fin n) R) := by
  induction' n with n ih
  · exact isRegularRing_of_ringEquiv (isEmptyRingEquiv R (Fin 0)).symm
  · let _ := Polynomial.isRegularRing_of_isRegularRing (MvPolynomial (Fin n) R)
    exact isRegularRing_of_ringEquiv (MvPolynomial.finSuccEquiv R n).toRingEquiv.symm
